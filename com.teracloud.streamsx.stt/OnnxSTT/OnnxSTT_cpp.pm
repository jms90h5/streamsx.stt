
package OnnxSTT_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/*', "\n";
   print ' * OnnxSTT operator implementation', "\n";
   print ' */', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
       my $encoderModel = $model->getParameterByName("encoderModel")->getValueAt(0)->getCppExpression();
       my $vocabFile = $model->getParameterByName("vocabFile")->getValueAt(0)->getCppExpression();
       my $cmvnFile = $model->getParameterByName("cmvnFile")->getValueAt(0)->getCppExpression();
       
       my $sampleRate = $model->getParameterByName("sampleRate");
       $sampleRate = $sampleRate ? $sampleRate->getValueAt(0)->getCppExpression() : "16000";
       
       my $chunkSizeMs = $model->getParameterByName("chunkSizeMs");
       $chunkSizeMs = $chunkSizeMs ? $chunkSizeMs->getValueAt(0)->getCppExpression() : "100";
       
       my $numThreads = $model->getParameterByName("numThreads");
       $numThreads = $numThreads ? $numThreads->getValueAt(0)->getCppExpression() : "4";
       
       my $provider = $model->getParameterByName("provider");
       my $useGpu = "false";
       if ($provider && $provider->getValueAt(0)->getSPLExpression() ne "CPU") {
           $useGpu = "true";
       }
   print "\n";
   print "\n";
   print '// Implementation code starts here', "\n";
   print '#include <SPL/Runtime/Common/ApplicationRuntimeMessage.h>', "\n";
   print '#include <SPL/Runtime/Utility/LogTraceMessage.h>', "\n";
   print '#include <iostream>', "\n";
   print '#include <vector>', "\n";
   print "\n";
   print 'using namespace SPL;', "\n";
   print 'using namespace std;', "\n";
   print "\n";
   print '// Using the SPL-generated namespace and class names', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR() ', "\n";
   print '    : initialized_(false)', "\n";
   print '    , audio_timestamp_ms_(0)', "\n";
   print '    , total_samples_processed_(0) {', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, "OnnxSTT operator constructor", "OnnxSTT");', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() {', "\n";
   print '    SPLAPPTRC(L_DEBUG, "OnnxSTT operator destructor", "OnnxSTT");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::initialize() {', "\n";
   print '    if (initialized_) return;', "\n";
   print '    ', "\n";
   print '    try {', "\n";
   print '        // Configure ONNX implementation', "\n";
   print '        config_.encoder_onnx_path = ';
   print $encoderModel;
   print ';', "\n";
   print '        config_.vocab_path = ';
   print $vocabFile;
   print ';', "\n";
   print '        config_.cmvn_stats_path = ';
   print $cmvnFile;
   print ';', "\n";
   print '        config_.sample_rate = ';
   print $sampleRate;
   print ';', "\n";
   print '        config_.chunk_size_ms = ';
   print $chunkSizeMs;
   print ';', "\n";
   print '        config_.num_threads = ';
   print $numThreads;
   print ';', "\n";
   print '        config_.use_gpu = ';
   print $useGpu;
   print ';', "\n";
   print '        ', "\n";
   print '        SPLAPPTRC(L_INFO, "Initializing OnnxSTT with model: " + config_.encoder_onnx_path, "OnnxSTT");', "\n";
   print '        ', "\n";
   print '        // Create implementation', "\n";
   print '        onnx_impl_ = onnx_stt::createOnnxSTT(config_);', "\n";
   print '        ', "\n";
   print '        // Initialize', "\n";
   print '        if (!onnx_impl_->initialize()) {', "\n";
   print '            SPLAPPTRC(L_ERROR, "Failed to initialize OnnxSTT", "OnnxSTT");', "\n";
   print '            throw std::runtime_error("OnnxSTT initialization failed");', "\n";
   print '        }', "\n";
   print '        ', "\n";
   print '        initialized_ = true;', "\n";
   print '        SPLAPPTRC(L_INFO, "OnnxSTT initialized successfully", "OnnxSTT");', "\n";
   print '        ', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Exception during initialization: " + string(e.what()), "OnnxSTT");', "\n";
   print '        throw;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {', "\n";
   print '    // Initialize on first tuple', "\n";
   print '    if (!initialized_) {', "\n";
   print '        initialize();', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    AutoPortMutex apm(_mutex, *this);', "\n";
   print '    ', "\n";
   print '    const IPort0Type& iport = static_cast<const IPort0Type&>(tuple);', "\n";
   print '    ', "\n";
   print '    // Get audio data', "\n";
   print '    processAudioData(iport.get_audioChunk());', "\n";
   print '    ', "\n";
   print '    // Get timestamp', "\n";
   print '    audio_timestamp_ms_ = iport.get_audioTimestamp();', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processAudioData(const SPL::blob& audio_blob) {', "\n";
   print '    // Get audio samples', "\n";
   print '    const int16_t* samples = reinterpret_cast<const int16_t*>(audio_blob.getData());', "\n";
   print '    size_t num_samples = audio_blob.getSize() / sizeof(int16_t);', "\n";
   print '    ', "\n";
   print '    if (num_samples == 0) return;', "\n";
   print '    ', "\n";
   print '    // Process with ONNX implementation', "\n";
   print '    auto result = onnx_impl_->processAudioChunk(samples, num_samples, audio_timestamp_ms_);', "\n";
   print '    ', "\n";
   print '    // Update stats', "\n";
   print '    total_samples_processed_ += num_samples;', "\n";
   print '    audio_timestamp_ms_ += (num_samples * 1000) / config_.sample_rate;', "\n";
   print '    ', "\n";
   print '    // Submit result if we have text', "\n";
   print '    if (!result.text.empty()) {', "\n";
   print '        submitResult(result);', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Log performance periodically', "\n";
   print '    if (total_samples_processed_ % (config_.sample_rate * 10) == 0) {', "\n";
   print '        auto stats = onnx_impl_->getStats();', "\n";
   print '        SPLAPPTRC(L_INFO, ', "\n";
   print '            "Processed " + to_string(total_samples_processed_ / config_.sample_rate) + ', "\n";
   print '            " seconds, RTF: " + to_string(stats.real_time_factor), ', "\n";
   print '            "OnnxSTT");', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::submitResult(const onnx_stt::OnnxSTTInterface::TranscriptionResult& result) {', "\n";
   print '    // Create output tuple', "\n";
   print '    OPort0Type otuple;', "\n";
   print '    ', "\n";
   print '    // Set attributes based on output schema: text, isFinal, confidence', "\n";
   print '    otuple.set_text(result.text);', "\n";
   print '    otuple.set_isFinal(result.is_final);', "\n";
   print '    otuple.set_confidence(result.confidence);', "\n";
   print '    ', "\n";
   print '    // Submit the tuple', "\n";
   print '    submit(otuple, 0);', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, ', "\n";
   print '        "Submitted: " + result.text + ', "\n";
   print '        " (final=" + to_string(result.is_final) + ', "\n";
   print '        ", latency=" + to_string(result.latency_ms) + "ms)", ', "\n";
   print '        "OnnxSTT");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port) {', "\n";
   print '    if (punct == Punctuation::FinalMarker) {', "\n";
   print '        // Reset the decoder on final punctuation', "\n";
   print '        if (onnx_impl_) {', "\n";
   print '            onnx_impl_->reset();', "\n";
   print '            SPLAPPTRC(L_DEBUG, "Reset decoder on final punctuation", "OnnxSTT");', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Forward punctuation', "\n";
   print '    submit(punct, 0);', "\n";
   print '}', "\n";
   print "\n";
   print '// End of implementation', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
