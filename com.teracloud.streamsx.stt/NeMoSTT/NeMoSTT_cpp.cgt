<%
    # Get parameters
    my $modelPath = $model->getParameterByName("modelPath");
    my $audioFormat = $model->getParameterByName("audioFormat");
    my $chunkDurationMs = $model->getParameterByName("chunkDurationMs");
    my $minSpeechDurationMs = $model->getParameterByName("minSpeechDurationMs");
    
    # Get input/output ports
    my $inputPort = $model->getInputPortAt(0);
    my $outputPort = $model->getOutputPortAt(0);
%>

/* Additional includes for NeMoSTT operator */
#include <iostream>
#include <cstring>

<%SPL::CodeGen::implementationPrologue($model);%>

<%
    my $modelPathValue = $modelPath->getValueAt(0)->getCppExpression();
    my $audioFormatValue = $audioFormat ? $audioFormat->getValueAt(0)->getSPLExpression() : '"mono16k"';
    my $chunkDurationValue = $chunkDurationMs ? $chunkDurationMs->getValueAt(0)->getCppExpression() : "5000";
    my $minSpeechDurationValue = $minSpeechDurationMs ? $minSpeechDurationMs->getValueAt(0)->getCppExpression() : "500";
%>

MY_OPERATOR::MY_OPERATOR()
    : sampleRate_(16000),
      channels_(1),
      modelPath_(<%=$modelPathValue%>),
      chunkDurationMs_(<%=$chunkDurationValue%>),
      minSpeechDurationMs_(<%=$minSpeechDurationValue%>)
{
    // Parse audio format
    std::string format = <%=$audioFormatValue%>;
    if (format == "mono8k") {
        sampleRate_ = 8000;
    } else if (format == "mono16k") {
        sampleRate_ = 16000;
    } else if (format == "mono22k") {
        sampleRate_ = 22050;
    } else if (format == "mono44k") {
        sampleRate_ = 44100;
    } else if (format == "mono48k") {
        sampleRate_ = 48000;
    }
    
    SPLAPPTRC(L_DEBUG, "NeMoSTT constructor: modelPath=" << modelPath_ 
              << ", sampleRate=" << sampleRate_ 
              << ", chunkDuration=" << chunkDurationMs_ << "ms"
              << ", minSpeechDuration=" << minSpeechDurationMs_ << "ms", 
              SPL_OPER_DBG);
}

MY_OPERATOR::~MY_OPERATOR() 
{
    SPLAPPTRC(L_DEBUG, "NeMoSTT destructor", SPL_OPER_DBG);
}

void MY_OPERATOR::allPortsReady() 
{
    SPLAPPTRC(L_DEBUG, "NeMoSTT allPortsReady", SPL_OPER_DBG);
    
    // Initialize NeMo STT
    nemoSTT_.reset(new com::teracloud::streams::stt::NeMoSTTWrapper());
    
    nemoSTT_->setChunkDurationMs(chunkDurationMs_);
    nemoSTT_->setMinSpeechDurationMs(minSpeechDurationMs_);
    
    if (!nemoSTT_->initialize(modelPath_)) {
        SPLAPPTRC(L_ERROR, "Failed to initialize NeMo model: " << modelPath_, SPL_OPER_DBG);
        throw std::runtime_error("Failed to initialize NeMo model");
    }
    
    SPLAPPTRC(L_INFO, "NeMo model initialized successfully", SPL_OPER_DBG);
}

void MY_OPERATOR::prepareToShutdown() 
{
    SPLAPPTRC(L_DEBUG, "NeMoSTT prepareToShutdown", SPL_OPER_DBG);
}

void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
    SPLAPPTRC(L_TRACE, "NeMoSTT process tuple", SPL_OPER_DBG);
    
    const IPort0Type & ituple = static_cast<const IPort0Type &>(tuple);
    
    // Extract audio data from input tuple
    // Assuming the tuple has a blob attribute containing audio data
    <%  
        # Find the first blob attribute in the input tuple
        my @attributes = $inputPort->getAttributes();
        my $blobAttr = undef;
        foreach my $attr (@attributes) {
            if ($attr->getSPLType() eq "blob") {
                $blobAttr = $attr;
                last;
            }
        }
        
        if ($blobAttr) {
            my $attrName = $blobAttr->getName();
    %>
    const SPL::blob& audioBlob = ituple.get_<%=$attrName%>();
    const void* audioData = audioBlob.getData();
    uint64_t audioSize = audioBlob.getSize();
    
    // Process audio data (assuming 16-bit samples)
    processAudioData(audioData, audioSize, 16);
    
    // Check for available transcription
    std::string transcription;
    if (nemoSTT_->getTranscription(transcription)) {
        outputTranscription(transcription);
    }
    <%
        } else {
    %>
    // No blob attribute found in input tuple
    SPLAPPTRC(L_ERROR, "No blob attribute found in input tuple", SPL_OPER_DBG);
    <%
        }
    %>
}

void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
    SPLAPPTRC(L_TRACE, "NeMoSTT process punctuation: " << punct, SPL_OPER_DBG);
    
    // On window marker, flush any remaining audio and get final transcription
    if (punct == Punctuation::WindowMarker) {
        std::string transcription;
        if (nemoSTT_->getTranscription(transcription)) {
            outputTranscription(transcription);
        }
        
        // Reset for next window
        nemoSTT_->reset();
    }
    
    // Forward punctuation
    submit(punct, 0);
}

void MY_OPERATOR::processAudioData(const void* data, size_t bytes, int bitsPerSample)
{
    size_t samples = bytes / (bitsPerSample / 8);
    
    // Convert to float samples
    audioBuffer_.clear();
    audioBuffer_.reserve(samples);
    
    if (bitsPerSample == 16) {
        const int16_t* samples16 = static_cast<const int16_t*>(data);
        for (size_t i = 0; i < samples; i++) {
            audioBuffer_.push_back(samples16[i] / 32768.0f);
        }
    } else if (bitsPerSample == 8) {
        const uint8_t* samples8 = static_cast<const uint8_t*>(data);
        for (size_t i = 0; i < samples; i++) {
            audioBuffer_.push_back((samples8[i] - 128) / 128.0f);
        }
    }
    
    // Process audio chunk
    nemoSTT_->processAudioChunk(audioBuffer_.data(), audioBuffer_.size(), sampleRate_);
}

void MY_OPERATOR::outputTranscription(const std::string& text)
{
    if (text.empty()) return;
    
    SPLAPPTRC(L_INFO, "Transcription: " << text, SPL_OPER_DBG);
    
    // Create output tuple
    OPort0Type otuple;
    
    <%
        # Set transcription text in the first rstring attribute
        my @outAttributes = $outputPort->getAttributes();
        foreach my $attr (@outAttributes) {
            if ($attr->getSPLType() eq "rstring") {
                my $attrName = $attr->getName();
    %>
    otuple.set_<%=$attrName%>(text);
    <%
                last;
            }
        }
    %>
    
    // Submit output tuple
    submit(otuple, 0);
}

<%SPL::CodeGen::implementationEpilogue($model);%>