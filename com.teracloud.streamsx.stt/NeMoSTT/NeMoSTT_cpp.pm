
package NeMoSTT_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
       # Get parameters
       my $modelPath = $model->getParameterByName("modelPath");
       my $audioFormat = $model->getParameterByName("audioFormat");
       my $chunkDurationMs = $model->getParameterByName("chunkDurationMs");
       my $minSpeechDurationMs = $model->getParameterByName("minSpeechDurationMs");
       
       # Get input/output ports
       my $inputPort = $model->getInputPortAt(0);
       my $outputPort = $model->getOutputPortAt(0);
   print "\n";
   print "\n";
   print '/* Additional includes for NeMoSTT operator */', "\n";
   print '#include <iostream>', "\n";
   print '#include <cstring>', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
       my $modelPathValue = $modelPath->getValueAt(0)->getCppExpression();
       my $audioFormatValue = $audioFormat ? '"' . $audioFormat->getValueAt(0)->getSPLExpression() . '"' : '"mono16k"';
       my $chunkDurationValue = $chunkDurationMs ? $chunkDurationMs->getValueAt(0)->getCppExpression() : "5000";
       my $minSpeechDurationValue = $minSpeechDurationMs ? $minSpeechDurationMs->getValueAt(0)->getCppExpression() : "500";
   print "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '    : sampleRate_(16000),', "\n";
   print '      channels_(1),', "\n";
   print '      modelPath_(';
   print $modelPathValue;
   print '),', "\n";
   print '      tokensPath_(),', "\n";
   print '      chunkDurationMs_(';
   print $chunkDurationValue;
   print '),', "\n";
   print '      minSpeechDurationMs_(';
   print $minSpeechDurationValue;
   print ')', "\n";
   print '{', "\n";
   print '    // Parse audio format', "\n";
   print '    std::string format = ';
   print $audioFormatValue;
   print ';', "\n";
   print '    if (format == "mono8k") {', "\n";
   print '        sampleRate_ = 8000;', "\n";
   print '    } else if (format == "mono16k") {', "\n";
   print '        sampleRate_ = 16000;', "\n";
   print '    } else if (format == "mono22k") {', "\n";
   print '        sampleRate_ = 22050;', "\n";
   print '    } else if (format == "mono44k") {', "\n";
   print '        sampleRate_ = 44100;', "\n";
   print '    } else if (format == "mono48k") {', "\n";
   print '        sampleRate_ = 48000;', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT constructor: modelPath=" << modelPath_ ', "\n";
   print '              << ", sampleRate=" << sampleRate_ ', "\n";
   print '              << ", chunkDuration=" << chunkDurationMs_ << "ms"', "\n";
   print '              << ", minSpeechDuration=" << minSpeechDurationMs_ << "ms", ', "\n";
   print '              SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT destructor", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT allPortsReady", SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // Derive tokens path from model path', "\n";
   print '    std::string modelDir = modelPath_;', "\n";
   print '    size_t lastSlash = modelDir.find_last_of("/\\\\");', "\n";
   print '    if (lastSlash != std::string::npos) {', "\n";
   print '        modelDir = modelDir.substr(0, lastSlash);', "\n";
   print '        tokensPath_ = modelDir + "/tokens.txt";', "\n";
   print '    } else {', "\n";
   print '        tokensPath_ = "tokens.txt";', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Initialize NeMo CTC implementation', "\n";
   print '    nemoSTT_ = createNeMoCTCImpl();', "\n";
   print '    ', "\n";
   print '    if (!nemoSTT_->initialize(modelPath_, tokensPath_)) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Failed to initialize NeMo CTC model: " << modelPath_, SPL_OPER_DBG);', "\n";
   print '        throw std::runtime_error("Failed to initialize NeMo CTC model");', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_INFO, "NeMo model initialized successfully", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT prepareToShutdown", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_TRACE, "NeMoSTT process tuple", SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    const IPort0Type & ituple = static_cast<const IPort0Type &>(tuple);', "\n";
   print '    ', "\n";
   print '    // Extract audio data from input tuple', "\n";
   print '    // Expecting tuple with audioChunk (blob) and audioTimestamp (uint64) attributes', "\n";
   print '    const SPL::blob& audioBlob = ituple.get_audioChunk();', "\n";
   print '    const void* audioData = audioBlob.getData();', "\n";
   print '    uint64_t audioSize = audioBlob.getSize();', "\n";
   print '    ', "\n";
   print '    // Convert 16-bit audio to float samples', "\n";
   print '    const int16_t* samples = static_cast<const int16_t*>(audioData);', "\n";
   print '    size_t numSamples = audioSize / sizeof(int16_t);', "\n";
   print '    ', "\n";
   print '    std::vector<float> floatSamples(numSamples);', "\n";
   print '    for (size_t i = 0; i < numSamples; ++i) {', "\n";
   print '        floatSamples[i] = static_cast<float>(samples[i]) / 32768.0f;', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Transcribe audio chunk', "\n";
   print '    std::string transcription = nemoSTT_->transcribe(floatSamples);', "\n";
   print '    ', "\n";
   print '    // Output transcription if not empty', "\n";
   print '    if (!transcription.empty()) {', "\n";
   print '        outputTranscription(transcription);', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_TRACE, "NeMoSTT process punctuation: " << punct, SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // Forward punctuation processing (CTC model handles each chunk independently)', "\n";
   print '    ', "\n";
   print '    // Forward punctuation', "\n";
   print '    submit(punct, 0);', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::outputTranscription(const std::string& text)', "\n";
   print '{', "\n";
   print '    if (text.empty()) return;', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_INFO, "Transcription: " << text, SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // Create output tuple', "\n";
   print '    OPort0Type otuple;', "\n";
   print '    ', "\n";
   print '    // Set transcription attribute (expecting rstring transcription)', "\n";
   print '    otuple.set_transcription(text);', "\n";
   print '    ', "\n";
   print '    // Submit output tuple', "\n";
   print '    submit(otuple, 0);', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
