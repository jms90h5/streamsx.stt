
package NeMoSTT_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
       # Get parameters
       my $modelPath = $model->getParameterByName("modelPath");
       my $audioFormat = $model->getParameterByName("audioFormat");
       my $chunkDurationMs = $model->getParameterByName("chunkDurationMs");
       my $minSpeechDurationMs = $model->getParameterByName("minSpeechDurationMs");
       
       # Get input/output ports
       my $inputPort = $model->getInputPortAt(0);
       my $outputPort = $model->getOutputPortAt(0);
   print "\n";
   print "\n";
   print '/* Additional includes for NeMoSTT operator */', "\n";
   print '#include <iostream>', "\n";
   print '#include <cstring>', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
       my $modelPathValue = $modelPath->getValueAt(0)->getCppExpression();
       my $audioFormatValue = $audioFormat ? $audioFormat->getValueAt(0)->getSPLExpression() : '"mono16k"';
       my $chunkDurationValue = $chunkDurationMs ? $chunkDurationMs->getValueAt(0)->getCppExpression() : "5000";
       my $minSpeechDurationValue = $minSpeechDurationMs ? $minSpeechDurationMs->getValueAt(0)->getCppExpression() : "500";
   print "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '    : sampleRate_(16000),', "\n";
   print '      channels_(1),', "\n";
   print '      modelPath_(';
   print $modelPathValue;
   print '),', "\n";
   print '      chunkDurationMs_(';
   print $chunkDurationValue;
   print '),', "\n";
   print '      minSpeechDurationMs_(';
   print $minSpeechDurationValue;
   print ')', "\n";
   print '{', "\n";
   print '    // Parse audio format', "\n";
   print '    std::string format = ';
   print $audioFormatValue;
   print ';', "\n";
   print '    if (format == "mono8k") {', "\n";
   print '        sampleRate_ = 8000;', "\n";
   print '    } else if (format == "mono16k") {', "\n";
   print '        sampleRate_ = 16000;', "\n";
   print '    } else if (format == "mono22k") {', "\n";
   print '        sampleRate_ = 22050;', "\n";
   print '    } else if (format == "mono44k") {', "\n";
   print '        sampleRate_ = 44100;', "\n";
   print '    } else if (format == "mono48k") {', "\n";
   print '        sampleRate_ = 48000;', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT constructor: modelPath=" << modelPath_ ', "\n";
   print '              << ", sampleRate=" << sampleRate_ ', "\n";
   print '              << ", chunkDuration=" << chunkDurationMs_ << "ms"', "\n";
   print '              << ", minSpeechDuration=" << minSpeechDurationMs_ << "ms", ', "\n";
   print '              SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT destructor", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT allPortsReady", SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // Initialize NeMo STT', "\n";
   print '    nemoSTT_.reset(new com::teracloud::streams::stt::NeMoSTTWrapper());', "\n";
   print '    ', "\n";
   print '    nemoSTT_->setChunkDurationMs(chunkDurationMs_);', "\n";
   print '    nemoSTT_->setMinSpeechDurationMs(minSpeechDurationMs_);', "\n";
   print '    ', "\n";
   print '    if (!nemoSTT_->initialize(modelPath_)) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Failed to initialize NeMo model: " << modelPath_, SPL_OPER_DBG);', "\n";
   print '        throw std::runtime_error("Failed to initialize NeMo model");', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_INFO, "NeMo model initialized successfully", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_DEBUG, "NeMoSTT prepareToShutdown", SPL_OPER_DBG);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_TRACE, "NeMoSTT process tuple", SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    const IPort0Type & ituple = static_cast<const IPort0Type &>(tuple);', "\n";
   print '    ', "\n";
   print '    // Extract audio data from input tuple', "\n";
   print '    // Assuming the tuple has a blob attribute containing audio data', "\n";
   print '    ';
     
           # Use hardcoded attribute name since we know the input schema
           my $attrName = "audioChunk";
       
   print "\n";
   print '    const SPL::blob& audioBlob = ituple.get_';
   print $attrName;
   print '();', "\n";
   print '    const void* audioData = audioBlob.getData();', "\n";
   print '    uint64_t audioSize = audioBlob.getSize();', "\n";
   print '    ', "\n";
   print '    // Process audio data (assuming 16-bit samples)', "\n";
   print '    processAudioData(audioData, audioSize, 16);', "\n";
   print '    ', "\n";
   print '    // Check for available transcription', "\n";
   print '    std::string transcription;', "\n";
   print '    if (nemoSTT_->getTranscription(transcription)) {', "\n";
   print '        outputTranscription(transcription);', "\n";
   print '    }', "\n";
       
   print "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    SPLAPPTRC(L_TRACE, "NeMoSTT process punctuation: " << punct, SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // On window marker, flush any remaining audio and get final transcription', "\n";
   print '    if (punct == Punctuation::WindowMarker) {', "\n";
   print '        std::string transcription;', "\n";
   print '        if (nemoSTT_->getTranscription(transcription)) {', "\n";
   print '            outputTranscription(transcription);', "\n";
   print '        }', "\n";
   print '        ', "\n";
   print '        // Reset for next window', "\n";
   print '        nemoSTT_->reset();', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Forward punctuation', "\n";
   print '    submit(punct, 0);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processAudioData(const void* data, size_t bytes, int bitsPerSample)', "\n";
   print '{', "\n";
   print '    size_t samples = bytes / (bitsPerSample / 8);', "\n";
   print '    ', "\n";
   print '    // Convert to float samples', "\n";
   print '    audioBuffer_.clear();', "\n";
   print '    audioBuffer_.reserve(samples);', "\n";
   print '    ', "\n";
   print '    if (bitsPerSample == 16) {', "\n";
   print '        const int16_t* samples16 = static_cast<const int16_t*>(data);', "\n";
   print '        for (size_t i = 0; i < samples; i++) {', "\n";
   print '            audioBuffer_.push_back(samples16[i] / 32768.0f);', "\n";
   print '        }', "\n";
   print '    } else if (bitsPerSample == 8) {', "\n";
   print '        const uint8_t* samples8 = static_cast<const uint8_t*>(data);', "\n";
   print '        for (size_t i = 0; i < samples; i++) {', "\n";
   print '            audioBuffer_.push_back((samples8[i] - 128) / 128.0f);', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Process audio chunk', "\n";
   print '    nemoSTT_->processAudioChunk(audioBuffer_.data(), audioBuffer_.size(), sampleRate_);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::outputTranscription(const std::string& text)', "\n";
   print '{', "\n";
   print '    if (text.empty()) return;', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_INFO, "Transcription: " << text, SPL_OPER_DBG);', "\n";
   print '    ', "\n";
   print '    // Create output tuple', "\n";
   print '    OPort0Type otuple;', "\n";
   print '    ', "\n";
   print '    ';
           # Set output attributes with hardcoded names
   print "\n";
   print '    otuple.set_text(text);', "\n";
   print '    otuple.set_isFinal(true);', "\n";
   print '    otuple.set_confidence(0.9);', "\n";
   print '    ';
       
   print "\n";
   print '    ', "\n";
   print '    // Submit output tuple', "\n";
   print '    submit(otuple, 0);', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
